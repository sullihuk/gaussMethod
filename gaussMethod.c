#include <stdio.h>
#include <math.h>
#include <stdbool.h>
#include <Windows.h>
#define row 4 //Установка константы количества уравнений/переменных в системе

void beTriangleMatrix (double system[row][row+1]); // Инициализация методов
void checkerZero (double system[row][row+1]);
void reverseSubs (double system[row][row+1]);
void printer (double system[row][row+1], int params);
void descrepancy(double system[row][row+1]);
double unvar[row]; //Инициализация массива значений искомых переменных.
double rVector[row];
double determinant = 1; // Инициализация переменной опеределителя  и присвоение значения по умолчанию
double sMatrix[row][row+1];// Инициализация двумерного массива обратной матрицы [S]

void checkerZero (double system[row][row+1]) // Метод избавляется от нулей на осевых элементах
{

	for (int i=0; i<row; i++) // Цикл пробегает по всем уравнениям системы
	{
		for(int j=0; j<row+1; j++) // Цикл пробегает по всем коэффициентам каждого уравнения
		{
			while (i==j && system[i][j]==0 && i!=row-1) // Если номер уравнения в системе равен номеру коэффициента, а коэффициент в свою очередь равен нулю, то к каждому коэффициенту прибавляется соотоветствующий коэффициент следующего в системе уравнения, умноженный на -1 (элементарные преобразования системы линейных уравнений)
			{
				for(j=0; j<row+1; j++)
				{
					system[i][j] += (system[i+1][j])*(-1);
				}
			}

			while (i==j && system[i][j]==0 && i==row-1) // Т.к. для последнего уравнения в системе нет следующего, что очевидно, к соответствующим коэффициентам последнего прибавляются коэффициенты предыдущего, также умноженные на -1, что не противоречит правилам элементарных преобразований 
			{
				for(j=0; j<row+1; j++)
				{
					system[i][j] += (system[i-1][j])*(-1);
				}
			}
		}
	}
}
			
void beTriangleMatrix (double system[row][row+1]) //Метод получает на вход матрицу и преобразует ее к т.н. треугольному (сверху) виду
{
	double divVal; // Инициализация переменной для замены частного коэффициентов. 

	for (int k=0; k<row; k++)// Цикл назначает номер шага исключения переменной
	{
		for (int i=k+1; i<row; i++)// Цикл пробегает по всем уравнениям системы, при том, что номер уравнения системы равен номеру шага исключения увеличенного на единицу, т.е. следующего
		{	
			double divVal = system[i][k]/system[k][k];//Вспомогательная переменная назначается как результат деления коэффициента следующего уравнения на соответсвующий коэффициент текущего уравнения 
			for (int j=k+1; j<=row; j++)// Цикл пробегает по всем коэффициентам текущего уравнения(строки)
				system[i][j] -= system[k][j]*divVal;// Каждый последующий коэффициент уравнения равен разнице между соответствующим коэффициентом на предыдущим шаге и коэффициентом на текущем шаге помноженным на вспомогательную переменную значение которой описано при ее назначении см. соответствующий комментарий
			  system[i][k]=0;// Коэффициенты не учавствующие в последующем расчете приравниваются к нулю
		}
	}
}

void reverseTriangle(double system[row][row+1] ) //Метод получает на вход матрицу и вычисляет обратную ей матрицу
{
  double auMat[row][row+1];// Инициализация вспомогательной матрицы, в которой правой части присваиваются соответствующие значения символа Кронекера 
  double auMat2[row][row+1];// Инициализация вспомогательной матрицы, в которой правой части присваиваются соответствующие значения символа Кронекера, эта матрица не преобразовывается для вычисления невязки обратной матрицы 
  printf("Вычисление обратной матрицы...\n");
  for (int t = 0; t<row; t++)
  {
    for(int i = 0; i<row; i++) 
    {
      auMat[i][row] = 0; //Присвоение правой части соответсвующего уравнению соответствующего символа Кронекера
      auMat2[i][row] = 0;//     --//--
      auMat[t][row] = 1;//     --//--
      auMat2[t][row]= 1; //     --//--
      for(int j=0; j<row; j++)// Присвоение левой части соответствующих значений изначальной матрицы
      {	
        auMat[i][j] = system[i][j];
        auMat2[i][j] = system[i][j];
      }	
    }
      puts("===================");
      beTriangleMatrix(auMat);// Вызов метода приводящего полученную матрицу к треугольному виду 
      printer(auMat, 1);// Вывод на экран преобразованной треугольной матрицы
      reverseSubs(auMat); //Вызов функции для проведения обратной подстановки текущей преобразованной матрицы
      printf("Невязка обратной матрицы для %d шага: \n", t+1);
      descrepancy(auMat2); //Вызов метода для вычисления невязки обратной матрицы
      for(int u = 0; u<row; u++) // Цикл заполняет столбцы искомой обратной матрицы
      {
        sMatrix[u][t] = unvar[u]; // Решения соответcтвующей системы являются соответствующим столбцом обратной матрицы
        //printf("%.2f\t\n",	sMatrix[u][t]);// Вывод решений на экран
      }
      puts("///////////////////");
  }
}

void reverseSubs (double system[row][row+1])// Метод реализует метод обратной подстановки. Параметром является какая-либо матрица.
{	

	char solution[]="xyzpq"; //Инициализация массива искомых переменных.
	for(int i=row-1; i>=0; i--) // Цикл решает систему уравнений методом обратной подстановки опираясь на значение последней переменной назначенной ранее
	{
		unvar[i] = system[i][row];// Назначение неизвестной переменной с номером, который соответствует номеру уравнения (счет уравнений ведется снизу вверх, что следует из названия метода)
		for(int j=i+1; j<row; j++)// Цикл вычисляет вспомогательное значение на основе предыдущих значений и соответствующих значений треугльной матрицы 
		{	
			unvar[i] -= system[i][j]*unvar[j]; // В теле цикла назначенное значение переназначается. В данном случае это значение является вспомогательным.
		}	
		unvar[i] /= system[i][i]; // Окончательное вычисление и присвоение соответствующего значения в массиве(наполнение массива вычисленными значениями)
	}
	
	for(int i=0; i<row; i++)//Цикл выводит на экран вычисленные значения переменных
		printf("%c = %.2f\n", solution[i], unvar[i]);
}

void printer (double system[row][row+1], int params) //Метод выводит на экран матрицу, поступающую на вход как параметр метода, второй параметр вводится для того, чтобы выводить матрицу иной размерности
{	
  if(params ==0)
    printf("Обратная матрица [S] = 1/[А]:\n");
	for (int i=0; i<row; i++)// Цикл выводит на экран значения матрицы, если значение на диагонали равно нулю оно выделяется квадратными скобками.
	{
    if(params == 1){
		for (int j=0; j<row+1; j++)
		{
        if (system[i][j] == 0 && i==j)
        { 
			printf(" [%.2f]",system[i][j]);
        }	else {
			printf(" %.2f ",system[i][j]);
        }
    }
      } else if(params == 0) {
        for(int j = 0; j<row; j++) {
        printf("%.2f\t", system[i][j]);
        }
	  }
		puts("");
  }
	puts("");
}

void auxilaryRate(double system[row][row+1], double auxilaryRate[row][row+1])// Метод записывает вспомогательную матрицу для вычисления обратной матрицы, т.к. исходная уже приведена к треугольному виду
{
  for (int i=0; i<row; i++) // Цикл пробегает по всем уравнениям системы
	{
		for(int j=0; j<row+1; j++) // Цикл пробегает по всем коэффициентам каждого уравнения
		{
		auxilaryRate[i][j] = system[i][j];
    }
  }
}

void descrepancy(double system[row][row+1])// Метод вычисляет невязку с точностью до тысячной доли
{
  double sum;
  bool truFal;
  double bVal;
  for (int i=0; i<row; i++) // Цикл пробегает по всем уравнениям системы
	{
		sum = 0;
		for(int j=0; j<row; j++) // Цикл пробегает по коэффициентам каждого уравнения, кроме свободного члена b
		{
			bVal = system[i][row];//Переменной присваивается значение свободного члена
			sum += system[i][j]*unvar[j];//Собственно, вычисление невязки
			rVector[i] = bVal - sum;
			if (sum - system[i][row] <= 0.001)
			truFal = true;
		}
		if (truFal == true) 
			printf ("%.10f ~= %f -- Верно!\n", sum, bVal);//Если правые и левые части уравнения отличаются на одну тысячную или менее выводится сообщение о верности решения}
		
	}
	printf ("Вектор невязки: ");
	for(int i=0; i<row; i++) {printf("%.15f ", rVector[i]);};//Если правые и левые части уравнения отличаются на одну тысячную или менее выводится сообщение о верности решения
	puts("");	
}

void determ(double system[row][row+1])// Метод вычисляет определитель матрицы методом Гаусса используя уже преобразованную, треугольную матрицу, хотя параметром может быть любая матрица соответствующей размерности, но тогда, значение переменной determinant не имеет смысла
{
  for (int i = 0; i<row; i++)
  {
	double multy;
      for( int j = 0; j<row; j++)
      {
        if (i == j )
        multy = system[i][j];
      }
      determinant *= multy;
  }
}

int main ()
{	
	system("chcp 65001");
	double rateAu[row][row+1];//Инициализация первоначальной матрицы
	double rate[row][row+1] = {      // Матрица заданной системы уравнений, предствленная в виде двумерного массива. Вариант 6. 
		{3.2, 5.4, 4.2, 2.2, 11.4},
		{2.1, 3.2, 3.1, 1.1, 9.2}, 
		{1.2, 0.4, -0.8, -0.8, 0.4}, 
		{4.7, 10.4, 9.7, 9.7, 30.4} 
	};

	auxilaryRate(rate, rateAu);//Вызов метода для сохранения первоначальной матрицы
	printf("Дано: \n");
	printer(rate, 1); //Вывод на экран первоначальной матрицы 
	printf("Удаление нулей на диагонали матрицы:\n");
	checkerZero(rate); // Преобразование матрицы к виду: без нулей на осевых элементах 
	printer(rate, 1);//Вывод на экран прeобразованной матрицы 
	printf("Преобразование матрицы к треугольному виду:\n");
	beTriangleMatrix(rate);// Преобразование матрицы к треугольному виду
	printer(rate, 1);//Вывод на экран треугольной матрицы 
	printf("Ответ:\n");
	reverseSubs(rate);//Метод обратной подстановки и вывод на экран значений соответствующих переменных, решенной системы линейных уравнений 
	printf("Невязка СЛАУ:\n");
	descrepancy(rateAu);//Вызов метода вычисляющего невязку. Проверка.
	determ(rate);//Вычисление определителя методом Гаусса.
	printf("Определитель |A|= %f\n", determinant);// Вывод на экран значения определителя для заданной матрицы
  //printer(rateAu, 1);// Вывод вспомогательной (первоначальной,т.к. матрица rate уже преобразована в треугольную) матрицы на экран 
	reverseTriangle(rateAu);// Вызов метода для вычисления обратной матрицы, и ее невязки
	printer(sMatrix, 0);// Вывод обратной матрицы на экран
}
	
